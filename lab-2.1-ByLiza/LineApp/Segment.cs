using System;

namespace LineApp
{
    public class Segment : Line
    {
        // Конструктор за замовчуванням, викликає конструктор базового класу
        public Segment() : base()
        //base — це ключове слово в C#, яке використовується для доступу до членів
        //  (методів, властивостей, конструкторів) базового класу з похідного класу. Воно дозволяє:

        //	1.	Метод GetLength() є публічним в базовому класі Line, і ви можете безпосередньо звертатися до нього з похідного класу Segment.
        //  У таких випадках, коли метод не перекривається (не перевизначається) в похідному класі, 
        // вам не потрібно використовувати base для його виклику.
        {
        }

        // Конструктор із параметрами, викликає конструктор базового класу
        public Segment(double startX, double startY, double endX, double endY)
            : base(startX, startY, endX, endY)
        {
        }

        //Конструктори не успадковуються, оскільки вони відповідають за ініціалізацію конкретного об’єкта, і кожен клас має свою специфічну ініціалізацію.
        //  Похідний клас може викликати конструктор базового класу через ключове слово base, щоб ініціалізувати поля базового класу перед власною ініціалізацією.


        // Конструктор копіювання, викликає конструктор базового класу
        public Segment(Segment other)
            : base(other)
        {
        }

        // Метод для отримання даних відрізка
        public string GetSegmentData()
        {
            return $"Початкова точка: ({StartX}, {StartY}), Кінцева точка: ({EndX}, {EndY})";
        }

        // Метод для зменшення довжини відрізка на 5 одиниць
        public void ReduceLengthBy5()
        {
            double length = GetLength();

            // Перевірка на те, чи довжина дорівнює 5
            if (length == 5)
            {
                Console.WriteLine("Помилка: довжина відрізка дорівнює 5, тому зменшити на 5 неможливо.");
                return; // Вихід з методу, якщо довжина дорівнює 5
            }

            // Перевірка на те, чи можна зменшити довжину на 5 одиниць
            if (length <= 5)
            {
                Console.WriteLine("Довжина відрізка занадто мала, щоб зменшити її на 5.");
                return; // Вихід з методу, якщо довжина занадто мала
            }
            else
            {
                // Обчислення масштабу для зміни довжини
                double scale = (length - 5) / length;

                // Обчислення нових координат кінця відрізка
                double newEndX = StartX + (EndX - StartX) * scale;
                double newEndY = StartY + (EndY - StartY) * scale;

                // Тут ти обчислюєш нові координати кінця відрізка, враховуючи масштаб. Як це працює:
                // • EndX - StartX — це відстань між початковою і кінцевою точкою по осі X.
                // • EndY - StartY — це відстань між початковою і кінцевою точкою по осі Y.

                // Оновлення координат кінця відрізка через метод базового класу
                SetEndCoordinates(newEndX, newEndY);
                Console.WriteLine("Довжина відрізка зменшена на 5.");
            }

            // Масштабування дозволяє пропорційно зменшити відрізок, тобто обидві точки змістяться на однакову відстань в тому ж напрямку,
            // зберігаючи правильну геометрію. Кінцева точка не просто “переміщається” на якусь фіксовану відстань,
            // а зміщується таким чином, що довжина відрізка скорочується рівномірно і правильно.

            // Ти множиш ці відстані на масштаб, щоб зменшити відстань пропорційно. Інакше кажучи, якщо відрізок має довжину 10 одиниць, і ти хочеш зменшити її на 5, 
            // ти масштабуватимеш його таким чином, щоб кінцева точка зсувалася на пропорційну відстань.
            // Для нахилених відрізків, щоб зберегти правильний напрямок і змінити довжину, потрібно використовувати масштабування.
        }
    }
}